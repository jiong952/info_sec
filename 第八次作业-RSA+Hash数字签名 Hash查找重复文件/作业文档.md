# RSA、Hash实现数字签名和验证

参考教程：https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626

使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。

## 文件描述

- RSA.py：封装了数字签名和验证
- test.py：测试类

## 测试验证

```python
Alice = RSACipher('Alice')
Bob = RSACipher('Bob')
Nancy = RSACipher('Nancy')

messages = 'hello world!'
# 私钥签名
Alice.sign(messages)
# 测试使用收到的公钥进行解密
Bob.check(messages, Alice, Alice.crypto)
# 测试使用错误的公钥进行解密
Nancy.check(messages, Bob, Alice.crypto)
```

分别测试使用和不使用Alice的公钥对签名进行验证

结果如下：

```
Alice签名成功！
Bob验证签名成功！消息来自Alice
Nancy验证失败，消息被破坏...
```

# 利用Hash函数查找本地硬盘重复文件

## 算法原理

基于python中的`hashlib`的md5加密算法读取文件内容更新hash值，如果文件内容相同则hash值相同

算法步骤：

1. 使用md5算法获得文件夹中每个文件的hash值
2. 将hash值作为key，文件存储路径作为value进行存储
3. 输出字典中相同key但是value大于1的所有文件

## 关键代码

```python
def md5sum(filename, blocksize=65536):
    hash = hashlib.md5()
    with open(filename, "rb") as f:
        for block in iter(lambda: f.read(blocksize), b""):
            hash.update(block)
    return hash.hexdigest()


def build_dup_dict(dir_path, pattern='*.jpeg'):
    def save(file):
        hash = md5sum(file)
        if hash not in dup.keys():
            dup[hash] = [file]
        else:
            dup[hash].append(file)

    p = Path(dir_path)
    for item in p.glob('**/' + pattern):
        save(str(item))
```



## 实验测试

![image-20221120123753762](img/image-20221120123753762.png)

![image-20221120123732488](img/image-20221120123732488.png)

算法正确查找到重复的6个图片文件并进行分类输出

# 中华人民共和国电子签名法

删去第三条第三款第二项；将第三项改为第二项，修改为：“（二）涉及停止供水、供热、供气等公用事业服务的”。

修改条款自决定公布之日起施行。

**修改前**

（一）涉及婚姻、收养、继承等人身关系的；

**（二）涉及土地、房屋等不动产权益转让的；**

（三）涉及停止供水、供热、供气、供电等公用事业服务的；

（四）法律、行政法规规定的不适用电子文书的其他情形。

**修改后**

（一）涉及婚姻、收养、继承等人身关系的；

（二）涉及停止供水、供热、供气等公用事业服务的；

（三）法律、行政法规规定的不适用电子文书的其他情形。

基于这次修订，意味着今后涉及土地、房屋等不动产权益转让、供电公用事业服务适用“电子签名、数据电文”。

参考链接：[最新《电子签名法》已正式施行，这些变化与你我息息相关！_数据 (sohu.com)](https://www.sohu.com/a/321351209_772729)